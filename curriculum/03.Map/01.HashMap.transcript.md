# HahsMap Transcript

## Inheritance Hierarchy

HashMap採用與List相同的接口、抽象基類和實現類的設計模式。實現類HashMap繼承了抽象基類AbstractMap，同時實現了接口Map。除了Map之外，HashMap還實現了接口Clonable和Serializable。

## Data Structure

HashMap的核心是一個hash table。Hash table是一個映射鍵值的數據結構。Hash table維護着一批bucket，每個bucket都可以存儲多個元素。這些bucket連續且有序地排列着。
Hash table使用hash function從鍵計算出bucket的位置索引，然後從bucket中檢索出目標值。

## Hash Fuction

理想情況下，hash function將每個鍵映射至不同的bucket上。但大部份hash table都會採用不完美的hash function。不完美的hash function會產生hash衡突，將多個鍵映射至同一個bucket中。
之所以大部份hash table採用不完美的hash function是因𤔡，完美的hash function極其難設計。所以，在實際應用中，hash衡突是不可避免的。

## Hash Function Properties

無論完美或不完美，hash function必須滿足四個要求：

* Determinism 確定性
* Uniformity 單調性
* Defined range 範圍限定
* Non-invertible 不同逆

hash function必須是確定的。給定相同的輸入，其必須輸出相同的值。換句話說，hash function必須是一個數學意義上的凾數。要滿足確定性，hash function就不能依賴外部變量，如隨機數生成器、時刻等。同時其也不能依賴內存地址。

一個良好的hash function 必須是單調的，其要尽可能地將輸入值均勻地分散到輸出值范圍內。hash table操作的時間繁雑度隨着hash衡突的數量增長而㥯速增長，而單調性可以保證蓋可能地減少hash衡突。

一般來講，hash function的輸出值域是固定的

鍳於完美的hash function幾乎是不可能設計出來的，所以，hash function都是一對多映射，所以，hash function 是不可逆函數。

## Operations

HashMap最常被使用的操作是put, remove和get。

## put

put操作將一組鍵值對存入HashMap。

假設給定一個hash table，其由10個bucket給成。1號bucket中已存有兩個元素；5號bucket中已存有三個元素；而8號bucket中已存有一個元素。
現在，嚮hash table中put一個鍵值對 38-thirty-eight。

## put - calculate hash code

首先，使用hash function計算鍵的hash code。
假設這里所使用的hash function是除十取餘。鍵38的hash code是8。

## put- Find Bucket

然後，以hash code 8𤔡位置索引定位到8號bucket。

## put - Add entry to Bucket

而此時，8號bucket中已有一個元素，且這個元索的鍵不等於38，這裏就遇到hash衡突。解決hash 衡突的方法很簡單，將新元素跟在已有元素後面即可。

## put - Code

這是JDK中的代碼實現。
首先，計算鍵的hash code；

## put - Code Cont'd

然後，以hash code𤔡位置索引，定位到bucket。在具體實現中，還需要一些額外處理。
比如，確保hash table已初始化；
再比如，用bucket數量除hash code取餘。因𤔡hash code的值域大於bucket的數量，所以需要將hash code映射到bucket位置索引域中，用的方法就是取餘。
找到bucket後,如果bucket𤔡空就直接將新元素添至bucket中。

## put - Code Cont'd 2

當目標bucket中已存有元素時有兩種可能，一是鍵已存在於map中，put操作就表現𤔡更新操作；另一種情況是hash衡突，多個鍵被映射至同一個bucket，這種情況就只需將新元素添到bucket的末尾即可。
這里首先判斷是否與bucket中第一個元素hash衡突，如果不是，則遍歷bucket中剩餘元素，判斷是鍵重復還是hash 衝突。HashMap中，bucket中的元素可以以樹結構存儲，也可能以鏈表結構存儲，所以這裏同時實現了樹遍歷和鏈表遍歷。

## put - Code Cont'd 3

## put - Time Complexity

put操作主要由hash code計算和bucket內遍歷元素兩部份運算組成。
hash code計算可以認𤔡是常數繁雑度的運算。在hash function分散比較均勻的情況下，bucket內遍歷元素運算也可以認𤔡是常數繁雑度的。所以整個put操作的時間繁雑度是常數。

## put - Benchmark

基準測試數據也支持其時間繁雑度𤔡常數的論斷。

## put - Benchmark

平均耗時並沒有隨着數據量的增長而增長。相反地，其一直維持在一個固定的範圍內。平均耗時和數據量之間的關系很貼合常數函數。

## V remove(Object key)

remove操作將移除指定鍵所關聯的鍵值對。
以圖示為例，給定一個HashMap，其中已存有六個鍵值對。現在要移除鍵為25的鍵值對。

## remove - Calculate Hash Code

首先，計算鍵的hash值。簡單起見，假設該hash function為除十除餘。則25的hash code是5。

## remove - Find Bucket

然後，以5為位置索引定位到5號bucket。

## remove - Lookuo Entry from Bucket

再然後，遍歷5號bucket中的元素。在實際應用中，所採用的hash function基本上都不是完美的。不完美的hash functon就會產生hash衡突。當出現hash衡突時，一個bucket中會存有多個鍵值對。需要遍歷比較鍵，從而找到目標鍵值對。

## remove - Lookup Entry from Bucket

找到目標元素，將其移除。具體的移除操作取決於bucket內的數據結構。

## remove - Code

這是JDK中的代碼實現。
首先，計算鍵的hash code。

## remove - Code Find Bucket

然後，以hash code為位置索引定位bucket。因為hash code的值域範圍大於bucket的縂數，所以要先將hash code映射至bucket的位置索引範圍內。

## remove - Code Address Entry

再然後，在bucket中遍歷比較鍵，查找目標鍵值對。

## remove - Code Remove Entry

最後，將找到的鍵值對移除。bucket中的元素是以二叉樹或鏈表存儲的。這裏需針對不同的存儲方式，採用不同的移除方法。

## remove - Time Complexity

remove操作由hash code計算、bucket內遍歷操作組成。可以認為是常數繁雑度操作。

## remove - Benchmark

基準測試數據也支持其時間繁雑度為常數的論斷。

## remove - Benchmark

平均耗時並沒有隨着數據量的增長而增長。相反地，其一直維持在一個固定的範圍內。其與數據量之間的關系很貼合常數函數。

## get(K key)

get操作與put操作類似。以圖示為例，給定一個HashMap，其中已存有六個鍵值對。現在要get鍵為25的值。

## get - Calculate Hash Code

首先，與put相同，計算鍵的hash code。這里我們依舊假設hash code是除十取餘。鍵25的hash code是5。

## get - Find Bucket

然後，以hash code5𤔡位置索引，找到目標bucket。

## get - Lookup Entry from Bucket

接着，遍歷bucket中的元素，找到包含目標鍵的元素。

## get - Lookup Entry from Bucket

## get - Code

這是JDK中的代碼實現。
首先，計算hash code。

## get - Code Cont'd

然後，以hash code𤔡位置索引，定位到bucket。若bucket不𤔡空，則遍歷bucket中的元素，否則即意味着目標鍵不存在於hash table。

## get - Time Complexity

get操作主要由hash code計算和遍歷bucket內元素兩部份運算組成。hash code計算可以認𤔡是常數時間繁雑度。遍歷bucket內元素，在hash function是良好實現的情況下，也可以認𤔡是常數時間繁雑度。所以整個get操作的時間繁雑度是常數。

## get - Benchmark

基準測試數據也支持其時間繁雑度是常數的論斷。

## get - Benchmark

平均耗時並沒有隨着數據量增長而增長。相反地，其一直維持在一個固定的範圍內。其與數據量之間的關系很貼合常數函數。

## Thank You
