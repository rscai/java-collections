# TreeMap Transcript

## Inheritance Hierarchy

TreeMap與HashMap相似，繼承了AbstrackMap，同時實現了接口Map。與HashMap不同的是，TreeMap實現了SortedMap接口。因為TreeMap是使用有序的紅黑樹來實現的，所以其可以實現SortedMap中定義的有序Map操作。

## Data Structure

TreeMap是用紅黑樹實現的。紅黑樹是二分搜索樹的一個特例，其滿足所有二分搜索樹的約束。

## Binary Search Tree Properties

二分搜索樹需要滿足五條約束：

1. 任意節點最多有兩個子樹；
2. 若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值；
3. 若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值；
4. 任意節點的左右子樹也分別為二分搜索樹；
5. 沒有鍵值相等的節點。

## Red-black Tree Properties

紅黑樹是每個節點都帶有顏色屬性的二分搜索樹，顏色為紅色或黑色。除了二分搜索樹的特性外，對於任何有效的紅黑樹需滿足五條額外約束：

1. 任意節點是紅色或黑色；
2. 根節點是黑色；
3. 所有葉子節點都是黑色；
4. 每個紅色節點必須有兩個黑色子節點；
5. 從任一節點到其每個葉子節點的所有簡單路踁都包含相同數目的黑色節點。

## Basic Operations

put，remove和get是最常用的Map操作。TreeMap將put實現為紅黑樹的插入操作；remove實現為紅黑樹的移除操作；而get則使用用二分搜索實現。

## Red-Black Tree Insertion

紅黑樹是在二分搜索樹的基礎上，使用紅黑兩種顏色標記節點實現樹不衡的數據結構。所以，TreeMap的put操作，即紅黑樹的插入操作由基本的二分搜索樹插入和標記顏色兩步組成。

## Binary Search Tree Insertion

二分搜索樹是一個遞歸結構，所以二分搜索樹插入也是一個遞歸算法。給定二分搜索樹T和值V：

1. 若T是空樹，則以V為值構造新節點N，並將N做為T的根節點；
2. 若V值等T的根節點的值，則將T根節點的值替換為V；
3. 若V值小於T根節點的值，則將V插入左子樹；
4. 將V插入右子樹「V值大於T根節點的值」。

## Binary Search Tree Insertion

這是一棵紅黑樹，從紅黑樹的定義可以得出，這也是一棵二分搜索樹。現在，假設要往這棵二分搜索樹中插入值3。

## Binary Search Tree Insertion

從根節點開始執行遞歸操作。
首先，檢查根節點是否為空，結果不是；
然後，比較根節點中的值，結果3是小於根節點中的值13；
所以，3應被插入到左子樹中。

## Binary Search Tree Insertion

在左子樹中繼續遞歸操作。
首先，檢查根節點是否空。現在的根節點是8，不為空；
然後，比較根節點中的值，結果3小於根節點中的值8；
所以，繼續將3插入到8的左子樹中。

## Binary Search Tree Insertion

在8的左子樹中繼續遞歸操作。
首先，檢查根節點是否為空。現在根節點是1，不為空；
然後，比較根節點中的值，結果3是大於根節點中的值1；
所以，3應該被插入到右子樹中。

## Binary Search Tree Insertion

在1的右子樹中繼續遞歸操作。
首先，檢查根節點是否為空。現在根節點是6，不為空；
然後，比較根節點中的值，結果3是小於根節點中的值6；
所以，3應該被插入到左子樹中。

## Binary Search Tree Insertion

在6的左子樹中繼續遞歸操作；
首先，檢查根節點是否為空，現在的根節點是空的。所以，將3插入為6的左子節點。

## Recoloring Cases

新節點的插入可能破壞紅黑樹的平衡，需要重新標色。
插入新節點後，紅黑樹可能處於四種狀態之一：

1. 新節點是紅黑樹的根節點
2. 新節點的父節點是黑色的
3. 新節點的父節點和叔父節點都是紅色的
4. 新節點的父節點是紅色的，但叔父節點是黑色的

## Insertion Recoloring - Case 1

如果新插入的節點是紅黑樹根節點，其有可能破壞特性2和5。所以將新節點即根節點涂為黑色。

## Insertion Recoloring - Case 1 Code

在JDK的代碼中，TreeMap在方法fixAfterInsertion中實現插入後的紅黑樹重新標色。
針對case1，fixAfterInsertion在最後一行代碼中將根節點標為黑色。

## Insertion Recoloring - Case 2

如果新插入的節點的父節點是黑色，則其不會破壞任何一條約束，所以不需任何重新標色。

## Insertion Recoloring - Case 3

如果新插入節點的父節點和叔父節點都是紅色，則其違返了約束4「如果某個節點是紅色，則其兩個子節點必須是黑色」。所以要反轉父節點、叔父節點和祖父節點的顏色。

## Insertion Recoloring - Case 3

反轉祖父節點顏色後，等同於在祖父節點的位置插入一個新的紅色節點。所以反轉父節點、叔父節點和祖父節點後，以祖父節點為當前節點，遞歸𢴇行重新標色。

## Insertion Recoloring - Case 3 Code

TreeMap的代碼實現中是分父節點為祖父節點的左子節點和右子節點兩種情形處理的。兩種情形的處理是對穪的。
當父節點和叔父節點都是紅色時，將父節點和叔父節點標為黑色，同時將祖父節點標為紅色。最後再以祖父節點為當前節點，遞歸套用重新標色操作。

## Insertion Recoloring - Case 4

如果新插入節點的父節點是紅色的且其叔父節點是黑色，則需調換當前節點、父節點和祖父節點的位置，將新節點和祖父節點轉換為父節點的左右子節點。

首先，調換新節點與父節點的位置。使用左、右璇轉方法可以保證調整後的節點依舊滿足二分搜索樹的約束。

## Rotate Left

左旋操作是將節點和其右子樹按逆時針方嚮旋轉。

## Rotate Left

旋轉之後的樹依舊滿足二分搜索樹的約束。

## Rotate Right

右旋則與左旋相反，將節點和其左子樹按順時針方嚮旋轉。

## Rotate Right

旋轉之後的樹依舊滿足二分搜索樹的約束。

## Insertion Recloring - Case 4 step 1

對於case4，首先旋轉當前節點和父節點，使當前節點上升一個層級，成為祖父節點的子節點。

## Insertion Recoloring - Case 4 step 2

然後，旋轉當前節點和祖父節點。最終使得當前節點上升至原祖父節點的層級，而原父節點和原祖父節點則成為當前節點的子節點。

## Put - Time Complexity

TreeMap的put由往二分搜索樹中插入元素和紅黑樹再平衡兩步組成。第一步往二分搜索樹中插入元素的時間複雜度為bigO logn。第二步紅黑樹再平衡一般可以在常數複雜度內完成。所以TreeMap的put縂體時間複雜度為big O logn。

## Put - Benchmark

基準測試數據也支持其時間複雜度為bigO logn的論斷。

## Put - Benchmark

平均耗時隨着數據量的增長而增長。且其關係很貼合對數函數關係。

## `V remove(K key)`

紅黑樹是二分搜索樹的一個特例，紅黑樹的移除操作由通用的在二分搜索樹中移除元素和重新標色兩步組成。

## Binary Search Tree Removal

在二分搜索樹中移除元素，首先以二分搜索法找到包含目標元素的節點，然後將其移除。
在二分搜索樹中移除節點有三種場景：

1. 被移除節點沒有子節點
2. 被移除節點拥有一個子節點
3. 被移除節點拥有兩個子節點

## Case 1: M has no child

場景一「被移除節點沒有子節點」很簡單，只需將目標節點移除即可。在紅黑樹中，葉子節點是不存儲元素的。所以，僅拥有葉子節點的節點等同於沒有子節點。

## Case 2: M has one child

場照二「被移除節點有一個子節點」。在這種情況下，將其子節點移至被移除節點的位置。

## Case 3: M has two children

場照三「被移除節點有兩個子節點」。這種情況下，從左右子樹中找到最接近被移除節點的節點來替代被移除節。可以從左子樹中尋找最大的節點，或者從右子樹中尋找最小的節點來替代被移除的節點。

## Case 3: M has two children

NA

## Removal - Rebalance

移除節點可能會使紅黑樹違反約束條件，需要再平衡操作來使得紅黑樹重新滿足五條約束。

從一樹完好的紅黑樹中移除一個節點，可能使這樹紅黑處於七種情況之一。

M表示被移除的節點，N表示M被移除後，佔據M原位置的節點。S是N的堂兄節點。P是N的父節點。SL和SR分別是S的左右子節點。

第一種情況，M是黑色但N是紅色；
第二種情況，N是根節點；
第三種情況，S𤴓紅色的；
第四種情況，P，S，SL和SR都是黑色的；
第五種情況，P是紅色的，但S，SL和SR是黑色的；
第六種情況，S是黑色的，SL和SL不同色；
第七種情況，其它。

針對每一種情況，需要採用不同的方式進行再平衡。

## Case 1: M is black abut N is red

第一種情況，M是黑色但N是紅色的。這種情況下，有可能違反紅黑樹的第四和第五修約束。這種情況下，將N標為黑色就可以保證滿足第四和第五條約束。
JDK中TreeMap將移除節點後的再平衡操作都實現在方法fixAfterDeletion中。
針對第一種情況，fixAfterDeletion將當前節點標為黑色。

## Case 2: N is root

第二種情況，N是根節點。這種情況下，可能違反第二條約束。將根節點標為黑色可以滿足第二條約束。

## Case 3: S is red - diagram

第三種情況，S是紅色。隠含地表明被移除的M是紅色的。這種情況下，不能簡單地將N標為紅色。黑色的M被除後，第五條約束已被違反。將N標為紅色不能使樹重新滿足紅黑樹的約束。

## Case 3: S is red - diagram

這里需要旋轉操作，將P進行左旋。將S提升一個層級，並將P及N降低一個層級。然後將P標為紅色，將S標為黑色。

## Case 3: S is red - Code

JDK中的代碼實現是分N為左子節和為右子節點兩種情形分別處理，先改變父節點和堂兄節點的顏色，再以父節點為基點旋轉。

## Case 4: P, S, SL anmd SR all are black - diagram

第四種情況，P，S，SL和SR都是黑色的。

## Case 4: P, S, SL and SR all are black - diagram

這種情況下，我們將S標為紅色。這個時候P到左子樹葉子節點的所有路踁中包含的黑色節點數，和到右子樹葉子節點的所有路踁中包含的黑色節點數不相等，它們相差一。這違反了紅黑樹第五條約束。所以，還要以P節點為起點，遞歸進行再平衡操作。

## Case 4: P, S, SL and SR all are black - Code

JDK中的代碼實現是分為N為左子節點和為右子節點兩種情形分別處理的。首先將堂兄節點標為紅色，再以父節點為起點，繼續進行再平衡操作。

## Case 5: P is red, but S, SL and SR are black

第五種情況，P是紅色的，但S，SL和SR是黑色的。

## Case 5: P is red, but S, SL and SR are black

這種情況，只需簡單地P將S和P反轉顏色，就轉化成第四種情況。然後繼續套用第四種情況的處理羅輯。

## Case 5: Code

第五種情況和第四種情況用同一段代源實現。

## Case 6: S is black, SL and SR are in different color

第六種情況，S是黑色的，SL和SR的顏色不同。

## Case 6: S is black, SL and SR are in different color

這種情況下，我們變換S和其之一子節點的顏色。然後以S為基點旋轉。

## Case 6: Code

JDK中代碼實現是分為N為左子節點和為右子節點兩種情形分別處理的。當N為左子節點時，將S的左子節點SL標為黑色，S標為紅色，以S為基點右旋。

## Case 6: Code

當N為右子節點時，將S的右子節點標為黑色，S標為紅色。再以S為基點左旋。

## Case 7: other

以上六種情況之外的即為第七種情況，P的顏色為任意，N和S是黑色的，與N對穪的S子節點為紅色（如N是左子節點，則S的右子節點為紅色；若N是右子節點，則S的左子節點為紅色）。

## Case 7: other

這種情況下，先調換P和S的顏色，再將相應的S子節點設為黑色，最後以P為基點旋轉。

## Case 7: Code

JDK中代碼實現是分N為左子節點時和N為右子節點時帀種種情形分別處理的。當N為左子節點時，先將P和S的顏色調換，再將S的右子節點標為黑色，最後以P為基點左旋。

## Case 7: Code

當N為右子節點時，先將P和S的顏色調換，再將S的左子節點標為黑色，最後以P為基點右旋。

## Remove - Time Complexity

從紅黑樹上移除節點由在二分搜索樹上搜索和再平衡兩步組成。由二分搜索樹定義可知，第一步操作在二分搜索樹上搜索的時間複雜度是bigO log n。第二步對紅黑樹再平衡一般能在常數複雜度內完成。所以TreeMap的remove縂體時間複雜度為bigO log n。

## Remove - Benchmark

基準測試數據也支持其時間繁雑度是bigO log n的論斷。

## Remove - Benchmark

平均耗時隨着數據量的增長而增長。且其關係很貼合對數函數關係。

## Get

TreeMap的get直接以二分搜索樹的二分搜索實現。

## Get - Time Complexity

紅黑樹是一個近似平衡的二分搜索樹，所在在紅黑樹中進行二分搜索的時間複雜度是bigO logn。

## Get - Benchmark

基準測試數據恃支持其時間複雜度bigOlogn的論斷。

## Get - Benchmark

平均耗時隨着數據量的增長而增長。且其關係很貼合對數函數關係。