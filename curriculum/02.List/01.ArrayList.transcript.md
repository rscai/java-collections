# ArrayList Transcript

## ArrayList

ArrayList是最常用的List實現。其實現了所有的可選List操作，其可接受任意元素，包括null。

## Inheritance Hierarchy

ArrayList繼承了抽象基類AbstractList且實現了接口List。
除了List接口外，ArrayList還實現了RandomAccess, Clonable和Serializable。

## Data Structure

ArrayList是使用原生數組實現可伸縮列表的。ArrayList在初始時分配一個固定大小的原生數組，該原生數組的長度即𤔡capacity，實際存儲的列表長度則記𤔡size。隨着列表的增長，當該原生數組無法容納所有元素時，即capacity小於size，ArrayList會創建一個更大的原生數組，並將原數組的內容拷貝至新數組，從而擴長容量。

## Operations

ArrayList實現了List接口中定義的所有操作。應用中最常用的有：

* 往列表末尾添加元素
* 往指定位置插入元素
* 获取指定位置的元素
* 移除指定位置的元素
* 將元素存放於指定位置
* 查找元素所存儲的位置

## Time Complexity

由於ArrayList使用原生數組存於列表，所以「往列表末尾添加元素」、「获取指定位置的元素」、「將元素存放於指定位置」三個操作時間繁雑度都是常數。
而「往指定位置插入元素」、「移除指定位置的元素」和「查找元素所存儲的位置」三個操作火竹日心戈時間繁雑度都是O(n)。

## add(E e)

「往列表未尾添加元素」。
ArrayList使用原生數組存儲位置，所列表末尾位置可以通過size直接得出。以圖𤔡例，當前原生數組已有五個元素，size是5。

## add(E e)

且數組的容量是10，所有無需擴容，直接將新元素存至位置5上。原生數組位置索引是從零開始的。
添加完元素後，更新size𤔡最新的列表長度。

## add(E e) Code

這是JDK中的代碼實現。首先確保原生數組容量足够容納新的元素，若不够則進行擴容。然後將新元素添加至列表末尾位置，同時將size加一。

## add(E e) Time Complexity

不考慮原生數組擴容的情況下，「往列表末尾添加元素」操作只需要進行兩次內存訪問。所以其時間繁雑度是O(1)，即常數時間繁雑度。

## add(E e) Benchmark

基準測試結果也支持其時間繁雑度𤔡常數的論斷。

## add(E e) Benchmark

從基準測試數據可以看出，操作耗時並沒有隨着數據量的增加而增加。數據量與平均耗時之間的關系很貼合常數函數曲線。

## add(int index, E element)

相比於「往列表末尾添加元素」，「往指定位置插入元素」需要多一個步操作，需要將指定位置及以後的元素嚮後移一位，以騰出空位給新元素。
以圖示𤔡例，將新元素X插入至位置3。

## add(int index, E element)

首先，需將位置3及其後邊的元素全部後移一位，騰空位置3。

## add(int index, E element)

然後，將新元素X存入位置3。
最後，將size加一。

## add(int index, E element) Code

這是JDK中的代碼實現。首先，進行位置索引越界檢查；然後，確保原生數組容量足够容納新元素；再然後，使用`System.arraycopy`將目標位置及其後面的元素嚮後移一位，以勝出位置容納新元素；再然後，將新元素存至目標位置；最後，size加一。

## add(int index, E element) Time Complexity

「往指定位置插入元素」因𤔡需要批量移動元素以騰出空位，所以其時間繁雑度取決於要移動的元素數量。
我們以計算步驟增長速度的上限來表示算法時間繁杂度。
先求出平均情況下步驟數與數據量的函數，我們得到一個多項式，消掉常量，得到時間繁雑度是O(n)。

## add(int index, E element) Benchmark

基準測試結果也支時其時間繁雑度𤔡O(n)的論斷。

## add(int index, E Element) Benchmark

平均耗時隨着數據量的增加而增加。且數據量與平均耗時之間的關系很貼合一元一次函數曲線。一元一次函數的增長速率上限即O(n)。

## get(int index)

「获取指定位置的元素」操作很簡單，ArrayList是用原生數組存儲元素的，所以列表上的位置索引即是原生數組索引。「获取指定位置的元素」操作可以直接以原生數組的索引訪問操作實現。

## get(int index) Code

這是JDK中的代碼實現。首先，進行位置索引越界檢查；然後，直接用原生數組的索引訪問操作訪問目標元素。

## get(int index) Time Complexity

「住指定位置插入元素」只需一次內存操作，所以其時間繁雑度是常數。

## get(int index) Benchmark

基準測試結果也支持其時間繁雑度𤔡常數的論斷。

## get(int index) Benchmark

平均耗時並沒有隨着數據量的增長而增長，相反地，其一直維持在一個固定的範圍內。且數據量和平均耗時之間的關系比較貼合常數函數。

## remove(int index)

「移除指定位置的元素」與「往指位置插入元素」類似，也需要嚮前移動元素以填補被移除元素留出來的空位。

## remove(int index)

首先，找到要移除的位置。

## remove(int index)

然後，將後邊的元素嚮前移動一位，正好䨱盖且填補空位。
最後，將size減一。

## remove(int index) Code

這是JDK中的代碼實現。首先是索引越界檢查；然後將要移除的目標元素讀取以備最後返回；再然後，將後面的元素嚮前移動一位；最後，將size加一。

## remove(int index) Time Complexity

「移除指定位置的元素」因𤔡要批量移動元素填補空位，所以其時間繁雑度取決於要移動的元素數量。
其時間繁雑度是O(n)

## remove(int index) Benchmark

基準測試數據也支持時間繁雑度是O(n)的論斷。

## remove(int index) Benchmark

平均耗時隨着數據量的增長而增長。其關系也很貼合一元一次函數。

## set(int index, E element)

「將元素存放於指定位置」沒有改變列表的長度，所以其不用移動元素去騰出空位或填補空位。

## set(int index, E element)

其只需直接通過原生數組的索引訪問目標位置，將元素䨱盖上即可。

## set(int index, E element) Code

這是JDK中的代碼實現。首先還是索引越界檢查；然後，讀取目標位置上的原值，以供返回用；最後，將新元素直接䨱盖至目標位置。

## set(int index, E element) Time Complexity

「將元素存放於指定位置」的時間繁雑度是常數。

## set(int index, E element) Benchmark

基準深試數據也支持「時間繁雑度是常數」的論斷。

## set(int index, E element) Benchmark

平均耗時並沒有隨着數據量的增長而增長。相反地，其一直維持在一個固定範圍內。數據量和平均耗時之間的關系也比較貼近常數函數。

## indexOf(Object 0)

「查找元素所存儲的位置」需要遍歷列表，一一比對，從而找到目標元素。

## indexOf(Object 0) Code

這是JDK中的代碼實現。ArrayList是接受null𤔡元素的，所以一一比對元素時分𤔡null值比較和對象比較。

## indexOf(Object o) Code

「查找元素所存儲的位置」需要遍歷列表，所以其時間繁雑度是O(n)

## indexOf(Object o) Benchmark

基準測試數據也支持其時間繁雑度𤔡O(n)的論斷。

## indexOf(Object o) Benchmark

平均耗時隨着數據量的增長而增長。其關系也很貼合一元一次函數。

## Thank You