# LinkedList Transcript

## LinkedList

LinkedList是另一個常用的List實現。其實現了所有的可選List操作，可接受任意元素，包括null。

```txt
Linked list 是另一个常用的List实现。其实现了所有的可选List操作，可接受任意元素，包括null。
```

## Inheritance Hierarchy

LinkedList繼承了抽象基類AbstractSequentialList，實現了List接口。此外，其還實現了Deque, Clonable和Serializable接口。

```txt
Linked list 继承了抽象基类Abstract Sequential List，实现了List接口。此外，其还实现了Deque, Clonable和Serializable接口。
```

## Data Structure

LinkedList是使用雙嚮鏈表存儲元素的。雙嚮鏈表中的每個節點都有前、後兩個引用，分別指嚮前方節點和後方節點。因為有了前、後兩個引用，使得雙嚮鏈表可以嚮前或嚮後兩個方嚮遍歷。LinkedList同時還持有頭、尾兩個引用，分別指嚮第一個節點和最後一個節點。對任意位置索引，可以就近從頭或從尾開始遍歷。
LinkedList的實現是非線程安全的。如果要多個線程並發訪問LinkedList，則必需進行額外的同步處理。

```txt
Linked list 是使用双向链表存储元素的。双向链表中的每个节点都有前、后两个引用，分别指向前方节点和后方节点。因为有了前、后两个引用，使得双向链表可以向前或向后两个方向遍历。 Linked list 同时还持有头、尾两个引用，分别指向第一个节点和最后一个节点。对任意位置索引，可以就近从头或从尾开始遍历。Linked list 的实现是非线程安全的。如果要多个线程并发访问 linked list，则必需进行额外的同步处理。
```

## Operations

LinkedList實現了List接口中定義的所有操作。應用中最常用的有：

* 往列表末尾添加元素
* 往指定位置插入元素
* 获取指定位置的元素
* 移除指定位置的元素
* 將元素存放於指定位置
* 查找元素所存儲的位置

```ssml
<speak>
    <s>Linked list 实现了List接口中定义的所有操作。</s>
    <s>应用中最常用的有：<break time="500ms"/>
        <emphasis>往列表末尾添加元素</emphasis><break time="250ms"/>
        <emphasis>往指定位置插入元素</emphasis><break time="250ms"/>
        <emphasis>获取指定位置的元素</emphasis><break time="250ms"/>
        <emphasis>移除指定位置的元素</emphasis><break time="250ms"/>
        <emphasis>将元素存放于指定位置</emphasis><break time="250ms"/>
        <emphasis>查找元素所存储的位置</emphasis><break time="250ms"/>
    </s>
</speak>
```

## Time Complexity

LinkedList是使用雙嚮鏈表實現，基於位置索引的操作都需從頭或從尾開始遍歷才能定位到目標元素，所以基于位置索引的操作時間複雜度都是O(n)。

```txt
Linked list是使用双向链表实现，基于位置索引的操作都需从头或从尾开始遍历，才能定位到目标元素，所以基于位置索引的操作时间复杂度都是 big O n。
```

## add(E e)

「往列表末尾添加元素」。通過指嚮尾部的引用，可以直接將尾部元素定位出來，無需遍歷鏈表。

```txt
「往列表末尾添加元素」。通过指向尾部的引用，可以直接将尾部元素定位出来，无需遍历链表。
```

## add(E e)

首先，創建一個新節點來存儲新元素，將新節點接到末尾節點後面。

```txt
首先，创建一个新节点来存储新元素，将新节点接到末尾节点后面。
```

## add(E e)

然後，把尾引用指嚮新的尾部節點。最後，把size加一。

```txt
然后，把尾引用指向新的尾部节点。最后，把size加一。
```

## add(E e) Code

這是JDK中的代碼實現。首先，通過尾部引用直接定位末尾節點。然後，創建一個新節點存儲新元素。同時將前嚮引用指嚮末尾節點，將尾引用指嚮新節點。如果原末尾節點不存在，即原鏈表為空，則將新節點同時設為頭節點。否則，將原末尾節點的後嚮引用指嚮新節點，即將新節點接到後面。最後，size加一。

```txt
这是JDK中的代码实现。首先，通过尾部引用直接定位末尾节点。然后，创建一个新节点存储新元素。同时将前向引用指向末尾节点，将尾引用指向新节点。如果原末尾节点不存在，即原链表为空，则将新节点同时设为头节点。否则，将原末尾节点的后向引用指向新节点，即将新节点接到后面。最后，size加一。
```

## add(E e) Time Complexity

「往列表末尾添加元素」操作無需遍歷鏈表，所以時間複雜度是常數。

```txt
「往列表末尾添加元素」操作无需遍历链表，所以时间复杂度是常数。
```

## add(E e) Benchmark

基準測試數據也支持時間複雜度為常數的論斷。

```txt
基准测试数据也支持时间复杂度为常数的论断。
```

## add(E e) Benchmark

平均耗時並沒有隨着數據量增長而增長。相反地，其一直維持在一個固定的範圍內。且平均耗時和數據量之間的關系比較貼合常數函數。

```txt
平均耗时并没有随着数据量增长而增长。相反地​​，其一直维持在一个固定的范围内。且平均耗时和数据量之间的关系比较贴合常数函数。
```

## add(int index, E element)

「往指定位置插入元素」操作需要遍歷鏈表定位目標位置。以在位置2插入元素X為例。

```txt
「往指定位置插入元素」操作需要遍历链表定位目标位置。以在位置2插入元素X为例。
```

## add(int index, E element)

比較目標索引和size，可知目標元素更接近於尾部。所以為了提升效率，從尾部開始嚮前遍歷。

```txt
比较目标索引和size，可知目标元素更接近于尾部。所以为了提升效率，从尾部开始向前遍历。
```

## add(int index, E element)

雙嚮鏈表的節點都是雙嚮連接的，嚮前逐個遍歷就可以定位到目標位置。

```txt
双向链表的节点都是双向连接的，向前逐个遍历就可以定位到目标位置。
```

## add(int index, E element)

創建新節點存儲新元素。

```txt
创建新节点存储新元素。
```

## add(int index, E element)

將新節點插入至目標節點之前。在雙嚮鏈表中插入節點只需改變前、後引用，無需移動整排元素。

```txt
将新节点插入至目标节点之前。在双向链表中插入节点只需改变前、后引用，无需移动整排元素。
```

## add(int index, E element) Code

這是JDK中的代碼實現。首先，是索引越界檢查。然後，檢查目標索引是否正好在鏈表末尾之後。如果是的話就等價於「往列表末尾添加元素」操作。如果不是，則定位到目標節點，將新元素插入至其之前。

```txt
这是JDK中的代码实现。首先，是索引越界检查。然后，检查目标索引是否正好在链表末尾之后。如果是的话就等价于「往列表末尾添加元素」操作。如果不是，则定位到目标节点，将新元素插入至其之前。
```

## add(int index, E element) Code -node

定位目標位置時，先判斷其是更接近頭部還是更接近尾部。然後，從頭或從尾部開始遍歷至目標置。

```txt
定位目标位置时，先判断其是更接近头部还是更接近尾部。然后，从头或从尾部开始遍历至目标位置。
```

## add(int index, E element) Code -linkBefore

定位到目標節點後，創建新節點，將新節點的前、後引用分別指嚮目標節點的前節點及目標節點；同時將目標節點的前嚮引用指嚮新節點，目標節點的前節點的後嚮引用指嚮新節點。即把新節點插入至目標節點之前。

```txt
定位到目标节点后，创建新节点，将新节点的前、后引用分别指向目标节点的前节点及目标节点；同时将目标节点的前向引用指向新节点，目标节点的前节点的后向引用指向新节点。即把新节点插入至目标节点之前。
```

## add(int index, E element) Time Complexity

因為要遍歷鏈表定位目標位置，所以其時間複雜度是O(n)。

```txt
因为要遍历链表定位目标位置，所以其时间复杂度是 big O n。
```

## add(int index, E element) Benchmark

基準測試數據也支持其時間複雜度為O(n)的論斷。

```txt
基准测试数据也支持其时间复杂度为 big O n 的论断。
```

## add(int index, E element) Benchmark

平均耗時隨着數據量的增長而增長，且其關系很貼合一元一次函數。

```txt
平均耗时随着数据量的增长而增长，且其关系很贴合一元一次函数。
```

## get(int index)

「获取指定位置的元素」操作也需要遍歷鏈表。

```txt
「获取指定位置的元素」操作也需要遍历链表。
```

## get(int index)

目標位置2更接近於尾部，所以從尾部開始嚮前遍歷。

```txt
目标位置2更接近于尾部，所以从尾部开始向前遍历。
```

## get(int index)

依次讀取前嚮節點直至到達目標位置。

```txt
依次读取前向节点直至到达目标位置。
```

## get(int index) Code

這是JDK中的代碼實現。首先，是索引越界檢查；然後，就是選擇從頭或從尾遍歷鏈表。

```txt
这是JDK中的代码实现。首先，是索引越界检查；然后，就是选择从头或从尾遍历链表。
```

## get(int index) Time Complexity

其時間複雜度等同於遍歷鏈表的時間複雜度，即O(n)。

```txt
其时间复杂度等同于遍历链表的时间复杂度，即O(n)。
```

## get(int index) Benchmark

基準測試數據也支持時間複雜度為O(n)的論斷。

```txt
基准测试数据也支持时间复杂度为O(n)的论断。
```

## get(int index) Benchmark

平均耗時隨着數據量的增長而增長，且其關系很貼合一元一次函數。

```txt
平均耗时随着数据量的增长而增长，且其关系很贴合一元一次函数。
```

## remove(int index)

「移除指定位置的元素」操作也需要遍歷鏈表。

```txt
「移除指定位置的元素」操作也需要遍历链表。
```

## remove(int index)

與size表較後發現目標位置更接近於尾部，所以從尾部開始嚮前遍歷。

```txt
与size比较后发现，目标位置更接近于尾部，所以从尾部开始向前遍历。
```

## remove(int index)

依次嚮前遍歷，定位在目標位置上。

```txt
依次向前遍历，定位在目标位置上。
```

## remove(int index)

然後，將目標節點移除。最後，將size減一。

```txt
然后，将目标节点移除。最后，将size减一。
```

## remove(int index) Code

這是JDK中的代碼實現。首先，還是索引越界檢查；然後，遍歷鏈表，找到目標節點。

```txt
这是JDK中的代码实现。首先，还是索引越界检查；然后，遍历链表，找到目标节点。
```

## remove(int index) - unlink

最後，將目標節點移除。同時將size減一。

```txt
最后，将目标节点移除。同时将size减一。
```

## remove(int index) Time Complexity

「移除指定位置的元素」操作等於在遍歷鏈表操作之後再加上常數量的幾步操作。所以，其時間複雜度也是O(n)。

```txt
「移除指定位置的元素」操作等于在遍历链表操作之后，再加上常数量的几步操作。所以，其时间复杂度也是 big O n 。
```

## remove(int index) Benchmark

基準測試數據也支持其時間複雜度為O(n)的論斷。

```txt
基准测试数据也支持其时间复杂度为 big O n 的论断。
```

## remove(int index) Benchmark

平均耗時隨着數據量的增長而增長。且其關系很貼合一元一次函數。

```txt
平均耗时随着数据量的增长而增长。且其关系很贴合一元一次函数。
```

## set(int index, E element)

「將元素存放於指定位置」操作也需要遍歷鏈表。

```txt
「将元素存放于指定位置」操作也需要遍历链表。
```

## set(int index, E element)

一樣地，跟size比較過後，發現目標位置更接近於尾部，所以從尾部開始嚮前遍歷。

```txt
一样地，跟size比较过后，发现目标位置更接近于尾部，所以从尾部开始向前遍历。
```

## set(int index, E element)

依次嚮前遍歷直至目標位置。

```txt
依次向前遍历直至目标位置。
```

## set(int index, E element)

最後，將新元素存入目標節點。

```txt
最后，将新元素存入目标节点。
```

## set(int index, E element) Code

這是JDK中的代碼實現。首先，還是索引越界檢查；然後，遍歷鏈表直至目標節點；最後，將新元素存入目標節點。

```txt
这是JDK中的代码实现。首先，还是索引越界检查；然后，遍历链表直至目标节点；最后，将新元素存入目标节点。
```

## set(int index, E element) Time Complexity

其時間複雜度相當於遍歷鏈表的時間複雜度，即O(n)。

```txt
其时间复杂度相当于遍历链表的时间复杂度，即 big O n。
```

## set(int index, E element) Benchmark

基準測試數據也支持其時間複雜度為O(n)的論斷。

```txt
基准测试数据也支持其时间复杂度为O(n)的论断。
```

## set(int index, E element) Benchmark

平均耗時隨着數據量的增長而增長，且其關系很貼合一元一次函數。

```txt
平均耗时随着数据量的增长而增长，且其关系很贴合一元一次函数。
```

## indexOf(Object o)

「查找元素所存儲的位置」操作不是基於位置索引的操作，但其依舊需要遍歷鏈表。

```txt
「查找元素所存储的位置」操作不是基于位置索引的操作，但其依旧需要遍历链表。
```

## indexOf(Object o)

因其不是基於位置索引的操作，所以不能從頭尾兩端中選擇最近的開始遍歷，而只能全部從頭開始遍歷。

```txt
因其不是基于位置索引的操作，所以不能从头尾两端中选择最近的开始遍历，而只能全部从头开始遍历。
```

## indexOf(Object o)

從頭開始，逐一遍歷節點。

```txt
从头开始，逐一遍历节点。
```

## indexOf(Object o)

直到找到目標元素。

```txt
直到找到目标元素。
```

## indexOf(Object o) Code

這是JDK中的代碼實現。沒有判斷其更接近於頭部還是更接近尾部，也無法判斷。其直接從頭開始遍歷，然後一一比較是否為目標元素。這裏只是區分了null值和非null對象的比較。

```txt
这是JDK中的代码实现。没有判断其更接近于头部还是更接近尾部，也无法判断。其直接从头开始遍历，然后一一比较是否为目标元素。这里只是区分了null值和非null对象的比较。
```

## indexOf(Object o) Time Complexity

「查找元素所存儲的位置」操作也是要遍歷鏈表的，所以其時間複雜度也為O(n)。

```txt
「查找元素所存储的位置」操作也是要遍历链表的，所以其时间复杂度也为 big O n。
```

## indexOf(Object o) Benchmark

基準測試數據也支持其時間複雜度為O(n)的論斷。

```txt
基准测试数据也支持其时间复杂度为 big O n 的论断。
```

## indexOf(Object o) Benchmark

平均耗時隨着數據量的增長而增長，且其關系很貼合一元一次函數。

```txt
平均耗时随着数据量的增长而增长，且其关系很贴合一元一次函数。
```

## Thank You